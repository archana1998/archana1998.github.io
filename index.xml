<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Archana Swaminathan</title>
    <link>https://archana1998.github.io/</link>
      <atom:link href="https://archana1998.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Archana Swaminathan</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Archana Swaminathan ©</copyright><lastBuildDate>Thu, 20 Aug 2020 10:53:53 +0530</lastBuildDate>
    <image>
      <url>https://archana1998.github.io/images/icon_hu616effff6bc497e1f3ccd40e4a444d66_14554_512x512_fill_lanczos_center_2.png</url>
      <title>Archana Swaminathan</title>
      <link>https://archana1998.github.io/</link>
    </image>
    
    <item>
      <title>Opening Keynote at the Google AI Summer School, 2020</title>
      <link>https://archana1998.github.io/post/opening-keynote/</link>
      <pubDate>Thu, 20 Aug 2020 10:53:53 +0530</pubDate>
      <guid>https://archana1998.github.io/post/opening-keynote/</guid>
      <description>&lt;p&gt;This article has been written from notes I took throughout the Opening Keynote at the Google AI Summer School. The opening keynote was delivered by &lt;a href=&#34;https://research.google/people/jeff/&#34;&gt; Jeff Dean&lt;/a&gt;, Head of Google AI and moderated by &lt;a href=&#34;https://research.google/people/106704/&#34;&gt;Manish Gupta&lt;/a&gt;, Director of Google AI Research, Bangalore. The Keynote was titled &lt;b&gt; Deep Learning to Solve Challenging Problems. &lt;/b&gt;&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Jeff Dean is a Senior Fellow at Google and the global head of Google AI. He saved Google at a very critical time and is essential to what contributed to make the Google Search Engine the best and the fastest in the world today. He is currently doing exciting research in the field of explainable AI for problems that the world is facing. He also helped create Tensorflow, the world&amp;rsquo;s most used Machine Learning Library.&lt;/p&gt;
&lt;h2 id=&#34;notes-from-the-talk&#34;&gt;Notes from the Talk:&lt;/h2&gt;
&lt;h3 id=&#34;the-marvel-of-deep-learning&#34;&gt;The marvel of Deep Learning&lt;/h3&gt;
&lt;p&gt;Deep Learning has revolutionized the way of solving challenging problems. There are over 130 new papers on Machine Learning on Arxiv every day. Deep Learning can be considered a modern reincarnation of Artificial Neural Networks. Key benefits and features of Deep Learning are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Availability of new network architectures&lt;/li&gt;
&lt;li&gt;Ability to scale to larger datasets and efficient computation of the math&lt;/li&gt;
&lt;li&gt;Learns features from raw, noisy, heterogenous data&lt;/li&gt;
&lt;li&gt;No explicit feature engineering required&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deep Learning architectures are remarkably flexible with taking in inputs and giving outputs of various forms, some examples are getting a categorical label from a pixel input (image), an audio input translating to a phrase that is a string, and language translation from one language to another.&lt;/p&gt;
&lt;p&gt;Deep Learning has also helped us come up with solutions to problems where the computer can achieve better results than a human. One such example is the &lt;a href=&#34;http://www.image-net.org/challenges/LSVRC/&#34;&gt;Imagenet challenge&lt;/a&gt;, that Stanford conducts every year that classifies images into classes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In 2011, the winner of the challenge was able to achieve 26% error, where humans were able to do the same task with 5% error.&lt;/li&gt;
&lt;li&gt;In 2012, &lt;a href= &#34;https://scholar.google.co.uk/citations?hl=en&amp;user=JicYPdAAAAAJ&#34;&gt;Geoffrey Hinton&lt;/a&gt; and his team used Deep Learning for the very first time in this challenge, and was the pioneer of bringing deep convolutional networks for the image classification task. Following his attempt, Deep Learning became very popular in further editions of the challenge.&lt;/li&gt;
&lt;li&gt;In 2017, the winner of the challenge was able to achieve 3% error on the Imagenet dataset, finally beating the human error of 5%.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;deep-learning-to-solve-world-problems&#34;&gt;Deep Learning to solve world problems&lt;/h3&gt;
&lt;p&gt;One thing that Jeff emphasized on, is how Deep Learning is being used to tackle the &lt;a href=&#34;http://www.engineeringchallenges.org/challenges.aspx&#34;&gt;Grand Engineering Challenges of the 21st century&lt;/a&gt;
One of the primary challenges that are under focus are restoring and improving urban infrastructure.&lt;/p&gt;
&lt;p&gt;A key advancement in this field is autonomous driving, which Deep Learning has aided to such an extent that the autonomous driving is far safer than the usual human driver, with 360-degree vision utilizing around 18 cameras to form a dense LiDAR point cloud.&lt;/p&gt;
&lt;p&gt;Another field that Deep Learning revolutionalized is combining vision with robotics. For the task of a robot arm picking up an unseen object,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In 2015, there was a 65% grasp success rate&lt;/li&gt;
&lt;li&gt;In 2016, with the robot trained to pick up multiple categories of objects, the accuracy rose up to 78%&lt;/li&gt;
&lt;li&gt;In 2018, this accuracy shot up to 96% when Deep Learning was introduced into the mix
Self supervised imitation learning also uses deep learning, which is the ability of a robot to imitate actions from pixels (human footage) without supervision&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another of these challenges was Advancing Health Informatics. We got an insight into what Google AI is working on for this field.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One of these is diagnosing diabetic retinopathy, the fastest growing cause of preventable blindness&lt;/li&gt;
&lt;li&gt;Screening of the individual can prevent blindness, however it is extremely specialized so most MD&amp;rsquo;s cannot do it.&lt;/li&gt;
&lt;li&gt;Google came up with a &lt;a href=&#34;https://ai.googleblog.com/2018/12/improving-effectiveness-of-diabetic.html&#34;&gt;model&lt;/a&gt; that could diagnose the disease from image scans of the eye, in 2016 it was at par with the performance of general opthamologists, and in 2017 the accuracy became State of the Art, with accuracy matching that of Retinal Specialists&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many of these challenges and advances in the field of engineering and technology depend on the ability to understand text. The 2017 Tranformer Paper: &lt;a href=&#34;https://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf&#34;&gt; Attention is all you need!&lt;/a&gt; was a revolutionary step in this direction, which was followed by &lt;a href=&#34;https://arxiv.org/abs/1810.04805&#34;&gt;BERT&lt;/a&gt; in 2018. BERT introduced principles for training that was very popular and appreciated, that are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pre train a model on the &amp;ldquo;fill in the blanks&amp;rdquo; task, using large amounts of self supervised text.&lt;/li&gt;
&lt;li&gt;This model is then fine tuned on individual language tasks, on a smaller scale.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This brought in light the desire to have large model architectures that are sparsely activated, that desirably have huge remembering capacity but utilize only a small fraction of the model while testing with individual examples
An example of this is the Per-Example Routing architecture.&lt;/p&gt;
&lt;p&gt;Jeff highlighted one of the most major contributions from Google towards deep learning, the introduction of the open-source deep learning library &lt;a href=&#34;https://www.tensorflow.org/&#34;&gt;Tensorflow&lt;/a&gt;. It remains the most popular and most downloaded Deep Learning Library until date, and has a vibrant open-source community, to the extent that only 1/3&lt;sup&gt;rd&lt;/sup&gt; of the current contributors are employees of Google!&lt;/p&gt;
&lt;h3 id=&#34;computer-architecture-for-deep-learning&#34;&gt;Computer architecture for Deep Learning&lt;/h3&gt;
&lt;p&gt;There was a time in the past where complex problems couldn&amp;rsquo;t be solved because of the lack of computational power. We have finally made strides that do not restrict the power available to us, so optimizing this is an important task.
Google AI has been focusing on redesigning computers, as Deep Learning has transformed this field completely. They kept two main things in mind while devising a computer to do deep learning:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First is, reduced precision is okay. The computer does not have to calculate results acccurately to the 10&lt;sup&gt;th&lt;/sup&gt; or 20&lt;sup&gt;th&lt;/sup&gt; decimal point.&lt;/li&gt;
&lt;li&gt;Second is, there are mostly only a handful of specific operations that constitute the math of Deep Learning, for example matrix multiplication, dot products, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keeping these in mind, Google introduced the &lt;a href=&#34;https://cloud.google.com/tpu/docs/tpus&#34;&gt;Tensor Processing Unit&lt;/a&gt;, that does just this. We can connect TPUs together to form Pods, that are currently available to the public on cloud services. Pods can be connected together to make supercomputers, that can train architectures like ResNet50 and Inceptionv2 in under 30 seconds! TPUs are being designed for edge applications also, to do deep learning on smartphones.&lt;/p&gt;
&lt;h3 id=&#34;problems-of-doing-machine-learning-today&#34;&gt;Problems of doing Machine Learning Today&lt;/h3&gt;
&lt;p&gt;The usual flow of work for a machine learning specialist is to collect the data, use his ML expertise (data augmentation, hyperparameter tuning etc) and train and test the model. A rather new approach that reduces human intervention here is &lt;a href=&#34;https://en.wikipedia.org/wiki/Automated_machine_learning&#34;&gt;AutoML&lt;/a&gt;, where the &amp;ldquo;ML expertise&amp;rdquo; is tuned and tested by automatic methods.&lt;/p&gt;
&lt;p&gt;Problems that still remain are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We still start with little to no knowledge about the problem and have to rely on random initialization&lt;/li&gt;
&lt;li&gt;New problems need significant data and compute power&lt;/li&gt;
&lt;li&gt;Transfer learning and multi-task learning help with this, but are done modestly&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-is-desired-to-be-achieved&#34;&gt;What is desired to be achieved&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Large but sparsely activated neural network architectures&lt;/li&gt;
&lt;li&gt;A single model that can be used to solve many tasks, by activating different parts of the network&lt;/li&gt;
&lt;li&gt;Dynamically adapting to new problems&lt;/li&gt;
&lt;li&gt;Adding new tasks easily&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus concluded the Keynote. It was fantastic and insightful. A couple of Q&amp;amp;A that I found interesting have been mentioned below:&lt;/p&gt;
&lt;p&gt;Q: What advice do you have for young researchers?&lt;/p&gt;
&lt;p&gt;A: Focus on problems that matter to you, and learn as much as you can. Create a constellation of techniques and ideas that can help you gather and organize your thoughts&lt;/p&gt;
&lt;p&gt;Q: How do you read new papers and get a gist of it?&lt;/p&gt;
&lt;p&gt;A: You&amp;rsquo;ll find many discussions on LinkedIn and Twitter about the paper, sometimes just reading this will give you a gist of what&amp;rsquo;s going on in the paper&lt;/p&gt;
&lt;p&gt;Q: Something unrealistic that you wish would happen in the field of AI in the future?&lt;/p&gt;
&lt;p&gt;A: The creation of a system that can absorb the world&amp;rsquo;s knowledge and solve all our problems&lt;/p&gt;
&lt;p&gt;Q: Hyperparameter tuning is expensive for large models, how do researchers work on this?&lt;/p&gt;
&lt;p&gt;A: Scaling down the problem to probably 1% of it and training and tuning that completely, and marginal scaling up to the level you desire is the best approach&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flipkart Grid 2.0 Hackathon</title>
      <link>https://archana1998.github.io/post/flipkart-grid/</link>
      <pubDate>Mon, 17 Aug 2020 17:39:32 +0530</pubDate>
      <guid>https://archana1998.github.io/post/flipkart-grid/</guid>
      <description>&lt;p&gt;Flipkart recently concluded their 2 month long annual hackathon for students of Indian engineering colleges. This year’s edition saw over 20,000 participants and boasted of a prize pool of around Rs. 300,000 (-4000 USD). Our team (Gradient Ascent) made it to the 3rd round of the competition and I am writing about our experience in this article.&lt;/p&gt;
&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;
&lt;p&gt;A fashion retailer wants to source ongoing and upcoming fashion trends from major online fashion portals and online magazines in a consumable and actionable format, so that they are able to effectively and efficiently design an upcoming fashion product portfolio.&lt;/p&gt;
&lt;p&gt;Deliverables:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Identify products that are better performers (in a rank ordered fashion)&lt;/li&gt;
&lt;li&gt;Help the user view the products that are both trending and lagging&lt;/li&gt;
&lt;li&gt;Identify a logic for classifying products as per their trendiness&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We were asked to complete the challenge for just the t-shirt product vertical, but to ensure that our solution would be scalable to other products as well.&lt;/p&gt;
&lt;h2 id=&#34;initial-analysis&#34;&gt;Initial Analysis&lt;/h2&gt;
&lt;p&gt;We started off by performing a literature review on current research in the field of fashion with respect to deep learning. We looked at previous attempts of learning attributes from fashion images, modelling trends as timeseries data, fashion image encodings, object detection, etc.&lt;/p&gt;
&lt;p&gt;After spending some time on our research, we split the problem into the following
subproblems to tackle independently:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Data Collection&lt;/li&gt;
&lt;li&gt;Object Detection&lt;/li&gt;
&lt;li&gt;Attribute/Feature learning&lt;/li&gt;
&lt;li&gt;Ranking&lt;/li&gt;
&lt;li&gt;Grouping (trending/lagging)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;data-collection&#34;&gt;Data Collection&lt;/h2&gt;
&lt;p&gt;According to the problem statement, we had to extract data from e-Commerce sites and other fashion portals and magazines. We tried our best to include data from all those categories to ensure we had a balanced dataset for our classification and ranking later on. After scouring the web for some good resources, we finally settled on the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Flipkart&lt;/li&gt;
&lt;li&gt;Amazon&lt;/li&gt;
&lt;li&gt;Pinterest (curated collections of fashion trends)&lt;/li&gt;
&lt;li&gt;Vogue India&lt;/li&gt;
&lt;li&gt;Myntra&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We felt this combination of multipurpose e-Commerce sites, well established fashion magazines, social network sites and dedicated fashion shopping sites would ensure we had good representation from all sectors. We collected an average of around 600 images from each website, giving us a total of 3000 to work with.
Web scraping was done in Python using the Selenium framework. The scripts used to scrape data from any website were pretty similar and any new sites could be added with minor modifications, hence this step was easily scalable.
From e-commerce sites, we scraped the images, product names, ratings and the number of reviews to with ranking later on. From the other portals, we extracted just the images.&lt;/p&gt;
&lt;h2 id=&#34;object-detection&#34;&gt;Object Detection&lt;/h2&gt;
&lt;p&gt;One of the biggest problems we faced when extracting images from fashion magazines and social media sites is that they don’t limit themselves to just t-shirts. When they put out a catalogue/collection, it has everything ranging from skirts to sweaters to scarves. Furthermore, even in pictures where the shirt was the highlight, other features such as the model’s pose, skin colour and distance from the camera could confuse our model in the later stages of this project. Keeping all this in mind, we decided to use an object detection model to filter our data to ensure we had only pictures of t-shirts. Additionally, we cropped the images according to their bounding boxes to counter the other aforementioned problems.
This was done using a pretrained YOLOv3 model trained on the DeepFashion2 dataset, implemented using PyTorch.&lt;/p&gt;
&lt;h2 id=&#34;attributefeature-learning&#34;&gt;Attribute/Feature learning&lt;/h2&gt;
&lt;p&gt;This is where we faced our major setback. Our initial plan was to train a model to learn the attributes (neck type, sleeve length, patterns, etc) and to return them back for later use. We were then going to perform FP growth on our set of attributes of each image to obtain the frequent itemsets which would correspond to the most common combination of features and hence, trending/popular styles.&lt;/p&gt;
&lt;p&gt;It didn&amp;rsquo;t work out however, as we couldn’t find an appropriate dataset to work with such a task given our time constraints so we had to try out our backup plan.&lt;/p&gt;
&lt;p&gt;Our plan involved getting numeric encodings for the fashion images in place of the attribute list and performing clustering on the encodings. The largest clusters would correspond to the most popular types of clothes, and similarly, the smallest clusters would represent the lagging ones, assuming our calculated encodings are a fair representation of the original image. Since we were working with just images (unlabeled) data, we had to devise an unsupervised approach for learning the image encodings. After considering various options, we decided to go ahead using an autoencoder based on a CNN architecture. We did this for 2 major reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Convolutional layers would help notice particular features of t-shirts such as the necktype length and patterns if any&lt;/li&gt;
&lt;li&gt;We can insight on how accurate our encodings to reconstruct the image&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here’s a summary of the model we used:&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-frequent-itemset-mining&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/post/flipkart-grid/1_hud8ee6b60bc41ae2f19ca216ed0cbf7e3_180328_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1265&#34; height=&#34;177&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Frequent Itemset Mining
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;We then plotted some of the reconstructed images side by side with their original counterparts and got pretty good results considering the simplicity of the network and size of the dataset. The encodings were able to capture some important features of the clothes in question.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-model-architecture&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/post/flipkart-grid/2_huf8d20e2591676411ac2452c151a71b7c_32522_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;352&#34; height=&#34;613&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Model Architecture
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;ranking&#34;&gt;Ranking&lt;/h2&gt;
&lt;p&gt;As far as e-commerce sites go, there are 2 main criteria used to determine how “good” a product is – the number of reviews and the rating it has. What would you consider to be better? 10 reviews with a 5-star rating? Or 50 reviews with a 4.7-star rating? This was the major question we had to answer to be able to rank these products properly. We needed an effective way of combining these 2 into one reliable metric. After doing some research on this area and tying out different methods of combing them, we settled with an approach based on  a Bayesian view of the beta distribution, described beautifully in this video by &lt;a href =&#34; https://www.youtube.com/watch?v=8idr1WZ1A7Q&amp;feature=emb_logo&#34;&gt;3blue1brown&lt;/a&gt;
We used this principle to come up with our own “Popularity Metric” which was calculated as follows:&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-reconstructed-images-from-encodings&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/post/flipkart-grid/3_hua9d9b1a4f907d92d1804ac04cfd1acaa_208064_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1093&#34; height=&#34;234&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Reconstructed Images from encodings
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;We now had a mechanism to compare and rank products effectively and a way to calculate accurate image encodings. We used both of these to train a model which predicts the Popularity Metric of a given clothing item given an input as the image encoding. We envisioned such a model to be extremely useful for designers that are looking for insight as to how their clothes might fair if they were put up for sale on e-commerce websites. Furthermore, the Popularity Metric could be calculated for all the images from magazines and portals like Vogue and Pinterest, so those products can be ranked and compared too!
The architecture, simplified pipeline and a screenshot of the program in action are shared below.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-popularity-metric&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/post/flipkart-grid/4_hu67e707b293e8bb2e83945f78f4b29e05_7331_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;238&#34; height=&#34;51&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Popularity Metric
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;center&gt; (n = number of reviews, s = star rating ) &lt;/center&gt;





  
  











&lt;figure id=&#34;figure-popularity-metric-model&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/post/flipkart-grid/5_hu1fc31ec500f87e3d3c214e201fb0429c_18291_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;540&#34; height=&#34;306&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Popularity Metric Model
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;grouping&#34;&gt;Grouping&lt;/h2&gt;
&lt;p&gt;Since the FP growth idea fell through the roof, we went with clustering as our method of choice for grouping products in such a way that we can obtain the trending and lagging items. To ensure our clustering was done well, we experimented on a variety of clustering algorithms and chose the one with the highest silhouette coefficient. The algorithms tested were –&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;K means&lt;/li&gt;
&lt;li&gt;Gaussian mixture model&lt;/li&gt;
&lt;li&gt;DBSCAN&lt;/li&gt;
&lt;li&gt;Mini batch k means&lt;/li&gt;
&lt;li&gt;Spectral clustering&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Among those, K means had the highest silhouette efficient so we went ahead with that. We then split the data into clusters according to how many images were being considered for clustering (no. of clusters = no. of images/10). The products in the largest cluster could be inferred as the trending/popular products and those in the smallest clusters would be lagging products. We gave the user the option to spec which sources they wanted to consider for their clustering, giving them more flexibility with regards to analyzing what’s not and what’s not (what’s trending on Vogue might not be popular on Amazon).&lt;/p&gt;
&lt;p&gt;To conclude, we were able to come up with a way to rank products properly and to group them based on whether they are trending or lagging. We also ensured that our solution is scalable on 2 fronts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Getting more data can be done easily with minor modifications to the existing script&lt;/li&gt;
&lt;li&gt;We can expand to different product verticals by changing the object of interest in the object detection model&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The link to the GitHub Repo is at the top of this page.
Hope you found this interesting, thanks for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Structural Damage Detection using ConvNets</title>
      <link>https://archana1998.github.io/project/damage-detection/</link>
      <pubDate>Sun, 16 Aug 2020 21:12:27 +0530</pubDate>
      <guid>https://archana1998.github.io/project/damage-detection/</guid>
      <description>&lt;p&gt;Presented our work at the &lt;a href = &#34;https://cmos.in1touch.org/site/congress_home&#34;&gt;  54th Canadian CMOS conference, 2020. &lt;/a&gt; Worked under the supervision of &lt;a href =&#34;https://scholar.google.co.in/citations?user=42ZAdYUAAAAJ&amp;hl=en&#34;&gt;Dr. S Radhika&lt;/a&gt;, of the Department of Electrical and Electronics Engineering, BITS Pilani. Manuscript accepted and to be published.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Contactless Gesture Recognition</title>
      <link>https://archana1998.github.io/project/gesture-recognition/</link>
      <pubDate>Sun, 16 Aug 2020 11:03:12 +0530</pubDate>
      <guid>https://archana1998.github.io/project/gesture-recognition/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Gesture Recognition Systems are commonly utilized as an interface between computers and humans, along with interacting with many electronic instruments. These systems can be classified into three classes as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Motion-based: When the user holds a device or a controller that detects the gesture made.&lt;/li&gt;
&lt;li&gt;Touch-based: When the system includes a touch-screen and the positions and directions of the finger or equivalent tool of the user are mapped, thus recognizing the gesture.&lt;/li&gt;
&lt;li&gt;Vision-based: When the system makes use of image and signal processing to detect gestures made without touching any device.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first two types of systems need the users to hold and contact certain devices, for the gesture recognition, and vision-based systems use camera setups, image processing and techniques that involve computer vision. These systems are difficult to set up for small scale use and are also expensive and extremely power hungry. For building a system that needs to function when there are limited resources available, it is important that the setup cost, power consumption and ease and size of setup is taken into consideration. Keeping this in mind, we have built a contactless gesture recognition system that consists of a couple of digital infrared sensors, that have been programmed to do the gesture recognition using a custom algorithm, with an Arduino Uno Microcontroller.&lt;/p&gt;
&lt;h2 id=&#34;problem-solving-methodology&#34;&gt;Problem Solving Methodology&lt;/h2&gt;
&lt;p&gt;Components Used and Setup:
The components we used are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Breadboard&lt;/li&gt;
&lt;li&gt;Arduino Uno Microcontroller&lt;/li&gt;
&lt;li&gt;2 digital IR Sensors&lt;/li&gt;
&lt;li&gt;Jumper wires&lt;/li&gt;
&lt;li&gt;Laptop for interfacing
Languages used:&lt;/li&gt;
&lt;li&gt;Arduino IDE (Based on C++)&lt;/li&gt;
&lt;li&gt;Python (for interfacing sensor output with VLC)&lt;/li&gt;
&lt;/ul&gt;





  
  











&lt;figure id=&#34;figure-setup&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/gesture-recognition/setup_hu3c30132babc4cc16104ed6d6062aecb7_271842_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;966&#34; height=&#34;724&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Setup
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;We connected two IR sensors to the Breadboard, placed at a distance of approximately 3 cm from each other. These were then interfaced with the Arduino Uno, which was connected to the laptop.&lt;/p&gt;
&lt;p&gt;Voltage is applied to the pair of IR LEDs, which in succession emit Infrared light. This light propagates through the air and once it hits the hand (or object), which acts as a hurdle, it is reflected back to the receiver. The LED on the diode glows, thus indicating that an object has been detected.&lt;/p&gt;
&lt;p&gt;A digital sensor system consists of the sensor itself, a cable, and a transmitter. The sensor has an electronic chip. The measuring signal is directly converted into a digital signal inside the sensor. The data transmission through the cable is also digital. This digital data transmission is not sensitive to cable length, cable resistance or impedance.&lt;/p&gt;
&lt;p&gt;Using the concept of states and delay as in Digital Design, we have created two states of the two sensors each placed on the left and right. These two states are defined and calibrated using a time delay of a few hundred microseconds in the gesture classification algorithm written using the Arduino IDE.&lt;/p&gt;
&lt;p&gt;We have taken two states in the algorithm into consideration namely Q(t) and Q(t+d) where d is the delay defined. The algorithm is defined such that left sensor and right sensor digital values are checked first and then after the defined delay, both sensors are checked for their Boolean values again and therefore the gesture is recognized and printed on the screen after running the code in the Arduino software. The chip on the Arduino Uno board plugs straight into the laptop’s USB port and supports the computer as a virtual serial port.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-state-table&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/gesture-recognition/table_hu2d1c1a3241fc2a5a508ad4f659b75269_15173_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;486&#34; height=&#34;209&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    State table
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;To make the gesture recognition feature interactive, we have interfaced the output with VLC Media player, so that we can pause, play and rewind/go forward with the playback. To do this interfacing, we have written a Python script, importing the Python library pyautogui, that provides functionality of control of the computer’s keyboard.&lt;/p&gt;
&lt;h2 id=&#34;results-and-conclusions&#34;&gt;Results and Conclusions&lt;/h2&gt;
&lt;p&gt;We tested the gesture recognition system for accuracy by using the precision-recall matric. We took in 30 different samples for input.
The precision is calculated as TP/(TP+FP), where TP denotes the number of true positives and FP denotes the number of false positives.
The precision of our system is = 90% (27 TPs and 3 FPs)&lt;/p&gt;
&lt;p&gt;The recall is calculated as TP/(TP+FN), where TP denotes the number of true positives, and FN denotes the number of false negatives.
The recall of our system is = 86.6% (26 TPs and 4 FNs)&lt;/p&gt;
&lt;p&gt;High precision implies that there is less chances of getting false alarms, and recall expresses the ability to find all relevant information from the dataset.
Practical Applications
We have integrated the recognition system with VLC, to control playback of the video. Similarly, the setup can easily be integrated with any mobile device that is low on resources, as well as used with complex devices, as IR sensors are fundamental in building light reflection systems and are extremely versatile.&lt;/p&gt;
&lt;h2 id=&#34;further-scope&#34;&gt;Further scope&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Friendly user interface that can be easily understood by any user and eventually its application can be extended to more applications like PDF reader, video games etc.&lt;/li&gt;
&lt;li&gt;Computationally inexpensive and low power consuming hardware and software setup, that makes it ideal for integrating with any device, both simple and complex.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ambient light obstructs the functioning as is the case with infrared sensors, as they are extremely sensitive. A proper optical barrier must be used to prevent this.&lt;/li&gt;
&lt;li&gt;We have assumed values of time delays between gestures according to what worked well for our test dataset. This leads to the system being slightly inflexible with different speeds of gestures.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Image Encryption and Decryption using Artificial Neural Networks</title>
      <link>https://archana1998.github.io/project/encryption-decryption/</link>
      <pubDate>Thu, 30 Jul 2020 12:05:59 +0530</pubDate>
      <guid>https://archana1998.github.io/project/encryption-decryption/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This project is inspired from the schematic described in the paper by I. A. Ismail
and Galal H. Galal-Edeen. A multilayer perceptron network is used for both the
encryption and decryption of images. The keys used for decryption are the fixed
bias vectors, which remain constant throughout training. Multiplicative neural
networks are used to help generate this constant vector, which is derived from a
vector specified by the sender. The images are sent into the neural network and
the output of the hidden layer gives the cipher. The cipher on being passed into
the output layer gives the decrypted image. The weights are trained and updated
using the backpropagation algorithm for learning, while the bias vector remains
constant.&lt;/p&gt;
&lt;p&gt;To get the constant bias vectors, the sender of the image specifies a numeric
vector of the same size as the layer it is a bias of. The vector is broken down
into subvectors and subsequent permutations of this vector are fed into a
multiplicative neuron. The output of the multiplicative neural network will be
added to the initial bias vector specified by the sender of the images. Since the
bias vector is now a constant that is entirely dependent on the way the initial
6bias vector is arranged, it provides an additional level of security over the
existing paradigm that employs a sender specified bias vector without any
modifications done to it.
All experiments have been done on, and results have been obtained from
MATLAB R2018b.&lt;/p&gt;
&lt;h1 id=&#34;multiplicative-neural-network&#34;&gt;Multiplicative Neural Network&lt;/h1&gt;
&lt;p&gt;A general structure for the multiplicative neuron is given below:&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-structure-of-multiplicative-neuron&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/encryption-decryption/1_hua14e20862d5f8aa201f826f6aacbb8a3_9020_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;485&#34; height=&#34;214&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Structure of multiplicative neuron
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;The input vector is (x 1 , x 2 ,&amp;hellip;..,x n ) which is a permutation of the initial specified bias vector. The weights vector is (w 1 , w 2, &amp;hellip;.., wn) and the bias vector (for this multiplicative neural network) is (b 1 , b 2, &amp;hellip;.., bn). Ω is a multiplicative operator and has the formula&lt;/p&gt;
&lt;p&gt;$$\Omega=\prod_{i=1}^{n}\left(w_{i} x_{i}+b_{i}\right)$$&lt;/p&gt;
&lt;p&gt;The output of the neuron is then processed using ƒ(u) which is the logsig function $y=\frac{1}{1+e^{-u}}$.&lt;/p&gt;
&lt;h2 id=&#34;training-algorithm&#34;&gt;Training Algorithm&lt;/h2&gt;
&lt;p&gt;The standard backpropagation algorithm has been modified for the training of
the multiplicative neural network, which is used in optimizing the weights and
biases. It is based on the popular steepest gradient descent approach. The error
function E is defined as&lt;/p&gt;
&lt;p&gt;$$E=\frac{1}{2 N} \sum_{p=1}^{N}\left(y_{p}-y_{p}^{d}\right)^{2}$$&lt;/p&gt;
&lt;p&gt;where $\ y_{p}^{d}$ is the desired output and y&lt;sub&gt;p&lt;/sub&gt; is the actual output for the p th input that is fed into the multiplicative neural network. The weights and biases of the model are updated using the following rules:&lt;/p&gt;
&lt;p&gt;$$w_{i}^{\text {new}}=w_{i}^{\text {old}}+\Delta w_{i}$$&lt;/p&gt;
&lt;p&gt;$$b_{i}^{\text {new}}=b_{i}^{\text {old}}+\Delta b_{i}$$&lt;/p&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;p&gt;$$\Delta w_{i}=-\eta \frac{d \boldsymbol{E}}{d w_{i}}=-\eta \frac{1}{N} \sum_{p=1}^{N}\left(\left(y_{p}-y_{p}^{d}\right) y_{p}\left(1-y_{p}\right) \frac{u}{w_{i} x_{i}+b_{i}} x_{i}\right)$$&lt;/p&gt;
&lt;p&gt;$$\Delta b_{i}=-\eta \frac{d \boldsymbol{E}}{d b_{i}}=-\eta \frac{1}{N} \sum_{p=1}^{N}\left(\left(y_{p}-y_{p}^{d}\right) y_{p}\left(1-y_{p}\right) \frac{u}{w_{i} x_{i}+b_{i}}\right)$$&lt;/p&gt;
&lt;p&gt;$\eta$ is the learning rate parameter. The main purpose of this parameter is to control the convergent speed as desired.&lt;/p&gt;
&lt;h2 id=&#34;procedure&#34;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;Two multiplicative neural network structures are used to generate the bias
vector for the hidden layer and output layer of the multilayer perceptron
network respectively. It is necessary to have a separate model for each vector as
the layers are of different dimensions (different number of neurons) and thus,
the bias vectors will be of different dimensions for both the hidden layer and the
output layer. The number of elements in the bias vector will be the size of the
input into the multiplicative neural network model, hence we require two
different models.&lt;/p&gt;
&lt;p&gt;The sender of the images first specifies a vector containing the same number of
elements as the number of neurons of the (hidden/output) layer of the MLP.
This is now broken down into subvectors (if the number of elements is 16, it can
be broken into 4 subvectors of 4 elements each, etc.). This breaking down is
essential as it becomes computationally difficult to calculate the permutations of
a combination of numbers greater than 10. Once the subvectors are obtained, the
individual permutations of each of the subvectors is stored into a matrix, which
are then concatenated to form a bigger matrix of size p*q where p is the number
of subvectors, and q is the dimension of the initially specified bias vector. A
target vector (dummy vector, but must remain constant and not be generated
randomly) is also specified by the sender.&lt;/p&gt;
&lt;p&gt;This matrix is now fed into as input to the multiplicative neural network, where
each row depicts an input sample. The network is trained using the algorithm specified, and the output is stored. This output is now added to the initial vector
specified by the sender for the MLP, and the result thus becomes the new bias
vector, which remains a constant throughout the experiment.&lt;/p&gt;
&lt;p&gt;This procedure is repeated for defining and training the second multiplicative
neural network, which generates the second bias vector for the MLP. Both these
vectors are essential for proper image encryption and decryption.&lt;/p&gt;
&lt;h1 id=&#34;mlp-used-for-image-encryption-and-decryption&#34;&gt;MLP used for image encryption and decryption&lt;/h1&gt;
&lt;p&gt;The network has a structure of one input layer, one hidden layer, and one output
layer. Adding further hidden layers can help in achieving image compression as
dimensionality of the image is being reduced. The output of the hidden layer gives the cipher and the output of the output layer gives the decipher of the image. There are N elements in the input layer that are fed to the next (hidden layer), which consists of M neurons. The output layer has the same number of neurons as the input layer.&lt;/p&gt;
&lt;p&gt;The MLP structure used in this project is given below.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-structure-of-mlp&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/encryption-decryption/2_hubb326033ac04905f65ab4941418dd105_12509_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;472&#34; height=&#34;413&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Structure of MLP
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;The network configuration is of NxMxN neurons which represent the input layer, hidden layer and output layer respectively. The sigmoid function (logsig) is used to generate the output of the hidden layer, which is defined as&lt;/p&gt;
&lt;p&gt;$$\text { Logsig function: } Z=\frac{1}{1+e^{\left[-\left(\left(\sum_{i=1}^{n} w_{1 i} x_{i}\right)+b_{1 i}\right)\right]}}$$&lt;/p&gt;
&lt;p&gt;where w&lt;sub&gt;1i&lt;/sub&gt; denotes the weight vector for the hidden layer, and b&lt;sub&gt;1i&lt;/sub&gt; denotes the bias vector for the hidden layer.&lt;/p&gt;
&lt;p&gt;The output of the output layer is calculated using a linear function (purelin in
MATLAB), which is defined as&lt;/p&gt;
&lt;p&gt;$$\text { Purelin function: } Y=m\left[\left(\sum_{i=1}^{n} w_{2 i} z_{i}\right)+b_{2 i}\right]+c$$&lt;/p&gt;
&lt;p&gt;where w&lt;sub&gt;2i&lt;/sub&gt; denotes the weight vector for the output layer, and b&lt;sub&gt;2i&lt;/sub&gt; denotes the bias vector for the output layer.&lt;/p&gt;
&lt;h2 id=&#34;training-algorithm-1&#34;&gt;Training Algorithm&lt;/h2&gt;
&lt;p&gt;The error of the output of the network in each step ‘n’ while training, (the
difference between the desired value and the actual value) is calculated by the
following formula.&lt;/p&gt;
&lt;p&gt;$$\Delta(n)=\left[\sum_{i=1}^{N}\left(x_{i}-y_{i}\right)^{2}\right]^{1 / 2}$$&lt;/p&gt;
&lt;p&gt;The weights are calculated using the following rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;For the hidden-output layer:&lt;/p&gt;
&lt;p&gt;a. The error signal for the q th neuron in the output layer is&lt;/p&gt;
&lt;p&gt;$$\delta_{q}=m\left(x_{q}-y_{q}\right)$$&lt;/p&gt;
&lt;p&gt;b. The updated weight w&lt;sub&gt;2(p, q)&lt;/sub&gt; is calculated as:&lt;/p&gt;
&lt;p&gt;$$\begin{array}{c}w_{2(p, q)}(n+1)=w_{2(p, q)}(n)+\Delta w_{2(p, q)}(n+1)\end{array}$$&lt;/p&gt;
&lt;p&gt;$$\begin{array}{c}\Delta w_{2(p, q)}(n+1)=\eta \delta_{q} z_{p}+\alpha\left[\Delta w_{2(p, q)}(n)\right]\end{array}$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For the input-hidden layer:&lt;/p&gt;
&lt;p&gt;a. The error signal for p&lt;sup&gt;th&lt;/sup&gt; hidden neuron is calculated using:&lt;/p&gt;
&lt;p&gt;$$\delta_{p}=z_{p}\left(1-z_{p}\right)\left[\sum_{k=1}^{N} \delta_{k} w_{1(p,k)}\right]$$&lt;/p&gt;
&lt;p&gt;b. The weight vector w&lt;sub&gt;1(i,p)&lt;/sub&gt;(n) is calculated similarly as the above
formula for the adjustment of weights, with z&lt;sub&gt;p&lt;/sub&gt; being replaced with
x&lt;sub&gt;i&lt;/sub&gt; and $\delta_{q}$ with $\delta_{p}$ .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;After one epoch, let $\Delta(n)$ and $\Delta(n+1)$ be the previous and current errors of the outputs of the neural network respectively. The rule that is followed
whether to decide if the weights are being updated or not, is:&lt;/p&gt;
&lt;p&gt;a. If $\Delta(n+1)&amp;gt;1.04[\Delta(n)]$,
The new weights, output, keys (always constant), error are
unchanged, and $\alpha$ is changed to $0.7 \alpha$&lt;/p&gt;
&lt;p&gt;b. If $\Delta(n+1)&amp;lt;=1.04[\Delta(n)]$,
All the variables except the keys are updated to their new values,
and $\alpha$ is modified to $1.05 \alpha$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These steps are carried out and repeated in each epoch, until the maximum
number of epochs has been reached, or the error becomes less than a value that
is predefined.&lt;/p&gt;
&lt;h2 id=&#34;procedure-1&#34;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;The keys obtained from the multiplicative neural network are first normalized to
lie within the range of (0,1). The normalization is simply done by dividing the
elements of the bias vector by the maximum value of the elements of the vector.&lt;/p&gt;
&lt;p&gt;The images that are fed into the neural network must all be of the same dimension, irrespective of them being training images or test images. For this project, images of various dimensions (256 x 256, 512 x 512 etc) have been scaled down to a dimension of 50 x 50. The images of this specified dimension are now segmented into sub images, of the number L (for the purpose of this project, L=100). The size of each sub image is x times x = N pixels, which makes N = 25. The segmentation is done using a custom defined segmentation function, that also converts each sub image into a 1-dimensional vector, and creates a matrix of dimension N x L (25 x 100) which is then fed in as input to the neural network.&lt;/p&gt;
&lt;p&gt;Once the network is trained with the training set, it is ready to encrypt and decrypt images. The test images are segmented using the same segmentation function which was used to segment the training images, and are fed into the trained neural network as input.&lt;/p&gt;
&lt;p&gt;The output of the hidden layer is computed using the output function (logsig),
which was previously defined. Since the size of the input image is NL, the output of the hidden layer is a matrix of size ML. (For this project, N = 25 and M = 16). The encrypted image (cipher) is then obtained after the output matrix is transformed into a 2-D matrix, for which the segmented images must be properly arranged back.&lt;/p&gt;
&lt;p&gt;The decrypted image is obtained when the output of the hidden layer is fed into
the output layer. In short, it is the final output of the neural network and can
directly be computed by feeding the input test image into the neural network.&lt;/p&gt;
&lt;h2 id=&#34;experiments-and-results&#34;&gt;Experiments and results&lt;/h2&gt;
&lt;p&gt;The project was done on MATLAB version R2018b on a computer with Intel
Core i5 6 th generation processor.&lt;/p&gt;
&lt;p&gt;The neural network was trained using 38 test images, out of which 14 were colour images, all downloaded from the USC Vision Database. The 14 colour images and any subsequent images henceforth used for testing were all converted into single channel images. The test images were segmented and passed into the neural network, which took approximately 40 seconds to train. The initial bias vectors were specified by the programmer and then was input into the two multiplicative neural networks to generate new elements, which were then added with the previous bias vector. Only after this, the bias vector for the MLP was fixed with this value and the MLP was made to train.&lt;/p&gt;
&lt;p&gt;Encryption and decryption of a test image of the Earth was extremely fast, with
the NPCR and UACI tests giving scores of 99.9665% and 0.34916 respectively. The PSNR ratios for the original image with the decrypted image and the cipher were 39.4156 and 39.3973 respectively.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compressive Sensing and Denoising of Images using the Ramanujan Fourier Transform</title>
      <link>https://archana1998.github.io/project/compressive-sensing/</link>
      <pubDate>Sat, 18 Jul 2020 18:40:47 +0530</pubDate>
      <guid>https://archana1998.github.io/project/compressive-sensing/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The Ramanujan Sums were first proposed by Srinivasan Ramanujan in 1918, and have become exceedingly popular in the fields of signal processing,time-frequency analysis and shape recognition. The sums are by nature, orthogonal. This results in them offering excellent conservation of energy, which is a property shared by Fourier Transform as well.&lt;/p&gt;
&lt;p&gt;We have used Matrix Multiplication to obtain the Ramanujan Basis, for our computation. The Ramanujan Sums are defined as n&lt;sup&gt;th&lt;/sup&gt; powers of q&lt;sup&gt;th&lt;/sup&gt;primitive roots of unity, which can be computed using this simple formula:&lt;/p&gt;
&lt;p&gt;$$c_{q}(n)=\mu\left(\frac{q}{g c d(q, n)}\right) \frac{\varphi(q)}{\varphi\left(\frac{q}{g c d(q, n)}\right)}$$&lt;/p&gt;
&lt;p&gt;Where $q=\prod_{i} q_{i}^{a_{i}}$,(q&lt;sub&gt;i&lt;/sub&gt; is prime). Then, $\varphi(q)=q \prod_{i}\left(1-\frac{1}{q i}\right)$.&lt;/p&gt;
&lt;p&gt;$\mu(n)$ is the Mobius function, which is equal to 0 if n contains a square number, 1 if n = 1 and (-1)*k if n is a product of k distinct prime numbers.&lt;/p&gt;
&lt;p&gt;The Ramanujan matrix can be defined as:&lt;/p&gt;
&lt;p&gt;$$A(q, j)=\frac{1}{\varphi(q) M} c_{q}(\bmod (j-1, q)+1)$$&lt;/p&gt;
&lt;p&gt;The 2-D forward Ramanujan Sum Transform is given as:&lt;/p&gt;
&lt;p&gt;$$Y(p, q)=\frac{1}{\varphi(p) \varphi(q)} \frac{1}{M N} \sum_{m=1}^{M} \sum_{n=1}^{N} x(m, n) C_{p}(m) C_{q}(n)$$&lt;/p&gt;
&lt;p&gt;which in matrix terms can be defined as&lt;/p&gt;
&lt;p&gt;$$Y=A * A^{\top}$$&lt;/p&gt;
&lt;p&gt;and the inverse 2D Ramanujan transform in matrix terms is:&lt;/p&gt;
&lt;p&gt;$$X=A^{-1} Y\left(A^{-1}\right)^{\top}$$&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-original-transformed-and-inversed-image&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/compressive-sensing/montage1_hu3f8e044785174c9754427187ccca8f30_16041_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;673&#34; height=&#34;184&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Original, Transformed and Inversed Image
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;compressive-sensing&#34;&gt;Compressive Sensing&lt;/h2&gt;
&lt;p&gt;The principle behind the use of compressive sensing as a signal processing technique, is that most test signals are not actually completely comprised of noise, but most have a great degree of redundancy in them. Sparse representation of signals in a particular domain signifies that most of the signal coefficients are either zero or close to zero.&lt;/p&gt;
&lt;p&gt;Compressive measurements, which are a weighed linear combination of signal samples, are first taken in a basis that is different from the sparse basis.&lt;/p&gt;
&lt;h3 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h3&gt;
&lt;p&gt;We use the generated Ramanujan Basis to do the sparse reconstruction. First, the sparse signal is obtained by multiplyingthe Ramanujan Basis A with the flattened image vector (here we are using the Cameraman Image that has been resized to 50 * 50).
Our Ramanujan Basis has dimensions of 2500 * 2500.&lt;/p&gt;
&lt;p&gt;Thus,&lt;/p&gt;
&lt;p&gt;$$Z=A^{*} x$$&lt;/p&gt;
&lt;p&gt;Where Z is the sparse representation of the cameraman image, and x is the flattened image vector of the original image.
We next create a random measurement matrix of dimension m*n, where we keep m = 5000 and n = 2500. This measurement matrix (Phi) is then multiplied by the sparse signal z.&lt;/p&gt;
&lt;p&gt;$$Y=P h i * Z$$&lt;/p&gt;
&lt;p&gt;We then use Orthogonal Matching Pursuit Algorithm, which aims to approximately find the most accurate  projections of data in multiple dimensions on to the span of a redundant or overcomplete dictionary. Here, the overcomplete dictionary we use is the Ramanujan Basis A.
The orthogonal matching pursuit algorithm is then applied onto the signal Y, and we have considered 1700 iterations.&lt;/p&gt;
&lt;p&gt;The plot of the original sparse representation and the OMP representation is given below:&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-plot-of-original-sparse-representation-blue-and-omp-representation-red&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/compressive-sensing/plot1_hudbf82b9e3e6b647977479df89ebf2cb6_10556_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;628&#34; height=&#34;333&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Plot of original sparse representation (blue) and OMP representation (red)
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;The image is then reconstructed by taking the inverse of the Ramanujan Basis, and multiplying it with the OMP sparse representation.&lt;/p&gt;
&lt;p&gt;$$R e c  =A^{-1} * x w s r$$&lt;/p&gt;
&lt;p&gt;Where xwsr is the OMP representation, and Rec is the reconstructed image signal. This is then resized to obtain the final image, which has been compared with the original image below:&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-original-and-final-image&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/compressive-sensing/orgvsfinal_hu69f64e62c985d6a5e0fb9a9c8fbbb991_25782_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;317&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Original and Final image
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;results&#34;&gt;Results&lt;/h3&gt;
&lt;p&gt;We compare and evaluate the performance of the Compressive Sensing Algorithm by using PSNR, SSIM and MSE image evaluation metrics.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSNR: Peak Signal to Noise Ratio&lt;/li&gt;
&lt;li&gt;SSIM: Structural Similarity Index&lt;/li&gt;
&lt;li&gt;MSE: Mean Square Error&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ideally, high values of PSNR, SSIM(max=1) and MSE show favourable performance of the reconstruction algorithm.The results obtained for this approach are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSNR = 23.1362&lt;/li&gt;
&lt;li&gt;SSIM = 0.6265&lt;/li&gt;
&lt;li&gt;MSE = 315.8316&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;image-denoising&#34;&gt;Image Denoising&lt;/h2&gt;
&lt;p&gt;Image denoising is commonly analysed and solved as an inverse problem. A method of doing this is to decompose the image signal in a sparse way, over a dictionary that is overcomplete. We use the Ramanujan Dictionary here to do the denoising, which is trained with three images using the K-SVD algorithm, based on Orthogonal Matching Pursuit (OMP).&lt;/p&gt;
&lt;h3 id=&#34;k-svd-algorithm&#34;&gt;K-SVD Algorithm&lt;/h3&gt;
&lt;p&gt;The K-SVD algorithm is a type of K-means clustering, which has been generalized. The k-
means clustering is also considered a method of doing representation of sparse signals. This
implies solving the equation below, to find the best code to represent the signal data {y&lt;sub&gt;i&lt;/sub&gt;} from i=1 to M&lt;/p&gt;
&lt;p&gt;$$\min &lt;em&gt;{D, X}\left{|Y-D X|&lt;/em&gt;{F}^{2}\right}, \text { subject to } \forall i,\left|x_{i}\right|_{0}=1$$&lt;/p&gt;
&lt;p&gt;F here is the Frobenius norm. The K-SVD algorithm is similar to the K-means in terms of the process of construction, but differs in the sense of the relaxation of the sparsity term in the constraint. This helps achieve a linear combination of the dictionary atoms. The relaxation is that the number of entries that are not zero in each column can be greater than 1, but less than a defined number T&lt;sub&gt;0&lt;/sub&gt;.&lt;/p&gt;
&lt;p&gt;Thus, the objective function hence becomes&lt;/p&gt;
&lt;p&gt;$$\min &lt;em&gt;{D, X}\left{|Y-D X|&lt;/em&gt;{F}^{2}\right} \text { , subject to } \forall i,\left|x_{i}\right|_{0} \leq T_{0}$$&lt;/p&gt;
&lt;p&gt;In the algorithm, the dictionary D is first fixed, and the aim is to find the perfect coefficient matrix X. To find this, a pursuit method that does the approximation of the optimal X is used. OMP was chosen as the suitable method to calculate the coefficients of the matrix here.&lt;/p&gt;
&lt;h3 id=&#34;implementation-and-results&#34;&gt;Implementation and Results&lt;/h3&gt;
&lt;p&gt;In the implementation for training the dictionary  nd the sparse data representation, the
parameters for the training are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Patch Size = 15&lt;/li&gt;
&lt;li&gt;Percentage of Overlap = 0.5&lt;/li&gt;
&lt;li&gt;Sparsity Threshold = 6&lt;/li&gt;
&lt;li&gt;Error Tolerance = 11.5
Three images, Boat, Lena and Barbara were used for the dictionary training. Patches were made
of these images and stacked. The number of iterations was the size of the stacked images that
formed the training data. In this case, the number was 2883. The dictionary and sparse data
representation were trained using the K-SVD algorithm and saved, the training process took
approximately 5.5 hours on an Intel i5 6 th gen processor, with a Nvidia 940mx GPU (personal laptop, using MATLAB R2019a).&lt;/li&gt;
&lt;/ul&gt;





  
  











&lt;figure id=&#34;figure-original-and-reconstructed-boat-image&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/compressive-sensing/reconmontage1_hu1cc507d436712babecbb0e0103bd6f3d_16355_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;205&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Original and Reconstructed Boat image
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;We added Gaussian Noise to a Lena Image and denoised it using the trained dictionary.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-original-noisy-and-denoised-lena-image&#34;&gt;



  &lt;img data-src=&#34;https://archana1998.github.io/project/compressive-sensing/denoised_huf16ae9dc124035bdd7e9ad8e397ffe59_15436_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;154&#34;&gt;



  
  
  &lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
    Original, Noisy and Denoised Lena image
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;MSE for noisy image = 68.0747&lt;/li&gt;
&lt;li&gt;MSE for denoised image = 55.2772&lt;/li&gt;
&lt;li&gt;PSNR for noisy image = 29.8009&lt;/li&gt;
&lt;li&gt;PSNR for denoised image = 29.9672&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;The Ramanujan Transform is a powerful transform and basis dictionary that can be used for sparse representation of an image. It can be trained efficiently and reconstructs images in a
better way as compared to using DCT dictionary. For compressive sensing algorithm, the training time of the Ramanujan dictionary is more compared to the DCT dictionary training time, but it is more efficient in reconstruction. It is also good at denoising images, and is efficiently trained using the K-SVD algorithm.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Deep Learning requires rethinking generalization</title>
      <link>https://archana1998.github.io/post/regularization/</link>
      <pubDate>Sat, 18 Jul 2020 14:11:22 +0530</pubDate>
      <guid>https://archana1998.github.io/post/regularization/</guid>
      <description>&lt;p&gt;This is a review of the ICLR 2017 paper by Zhang et. al. titled &amp;ldquo;Understanding Deep Learning requires rethinking generalization&amp;quot;&lt;a href = &#34;https://bengio.abracadoudou.com/cv/publications/pdf/zhang_2017_iclr.pdf&#34;&gt; Link to paper &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The paper starts off with aiming to provide an introspection into what distinguishes networks that generalize well, from those who don’t.&lt;/p&gt;
&lt;p&gt;One of the experiments conducted in the studies of the paper, is checking how well neural networks adapt to training when labels are randomized. Their findings establish that when the true data is completely randomly labelled, the training error that results is zero. Observations from this indicate that the effective capacity of neural networks is more than enough to memorize the entire dataset. Randomization of the labels is only a transformation of the data, and other learning parameters are constant and unchanged still. The resulting training time also increases by only a small factor. However, when this trained network is tested, it does badly. This indicates that just by randomizing labels, the generalization error can shoot up significantly without changing any other parameters of the experiment like the size of the model, the optimizer etc.&lt;/p&gt;
&lt;p&gt;Another experiment conducted was that when the ground truth images were switched with random noise. This resulted in the networks training to zero training error, even faster than the case with the random labels. Varying the amount of randomization resulted in a steady deterioration of the generalization error, as the noise level increased. There were a wide variety of changes introduced into the dataset, that played with degrees and kinds of randomization with the pixels and labels. All of this still resulted in the networks able to fit the training data perfectly. A key takeaway from this is that the neural networks are able to capture the signals remaining in the data, while fitting the noise and randomization with brute force. The question that still remains unanswered after this is why some models generalize better than others, because it is evident that some decisions made while constructing model architectures do make a difference in its ability to generalize.&lt;/p&gt;
&lt;p&gt;Traditional approaches in statistical learning theory such as Rademacher complexity, VC dimension and uniform stability are threatened by the randomization experiments performed.&lt;/p&gt;
&lt;p&gt;Three specific regularizers are then considered to note the impact of explicit regularization, data augmentation, weight decay and dropout. These are tried out on Inception, Alexnet and MLPs on the CIFAR10 dataset, and later with ImageNet. Regularization helps to improve generalization performance, but the models still generalize well enough with the regularizers turned off. It was then inferred that this is more of a tuning parameter than a fundamental cause of good generalization. A similar result was noted with implicit regularization.&lt;/p&gt;
&lt;p&gt;An interesting result proved in the paper was that there two layer depth networks of linear size, that can represent any labelling of the training data. A parallel approach in trying to understand the source of regularization for linear models was also not easy to point out.
To sum up, this paper presents a thorough insight into how empirically easy optimization does not imply good regularization, and effective capacity of network architectures is better understood and defined.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
